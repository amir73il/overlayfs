#!/bin/sh
#
# Overlayfs snapshot management script
#
#-----------------------------------------------------------------------
#
# Copyright (C) 2016 CTERA Networks. All Rights Reserved.
# Author: Amir Goldstein <amir73il@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#-----------------------------------------------------------------------
#

SCRIPT_NAME=$(basename $0)
SCRIPT_VER=0.1
FSTYPE=overlay
SCRIPT_DESC="$FSTYPE snapshot management script"
CMD="$1"

version()
{
	echo "$SCRIPT_NAME v$SCRIPT_VER ($SCRIPT_DESC)"
}

usage()
{
	version
	echo "usage: $SCRIPT_NAME help [cmd]"
	echo "usage: $SCRIPT_NAME version"
	echo
	echo "$FSTYPE snapshot commands:"
	echo "usage: $SCRIPT_NAME {status|list}  [<path>|-a]"
	echo "usage: $SCRIPT_NAME {umount|mount} [<path>|-a]"
	echo "usage: $SCRIPT_NAME {create|take}  <path>[[/]@[/]<snapshot-name>] (default-name=<date.time>)"
	echo "usage: $SCRIPT_NAME {delete|remove} <path>[/]@[/]<snapshot-name>"
	echo "usage: $SCRIPT_NAME {clean}         <path>"
	echo
	echo "snapshot command parameter may be given in ZFS style <path>@<snapshot-name>"
        echo "and it may be given as the snapshot directory path <path>/@/<snapshot-name>."
	echo "If <snapshot-name> part is omitted, command may apply to all snapshots (e.g. umount)."
	echo
	echo "$FSTYPE snapshot test commands:"
	echo "usage: $SCRIPT_NAME {test|tests} <path> [test-number] [file-size-mb]"
	echo
	exit 1
}

error()
{
	echo "$SCRIPT_NAME: $CMD: $1" >&2
	exit 1
}

# parse <path>[[/]@[/]<snapshot-name>] argument
parse_path_snapshot_arg()
{
	MNT=$( echo $1 | ( IFS=$IFS@ ; read a b ; echo $a ) )
	snap=$( echo $1 | ( IFS=$IFS@ ; read a b ; echo $b ) )
	# strip / from <path>/ and /<snapshot-name>
	MNT=${MNT%/}
	snap=${snap#/}
	# directory inside <path> to store snapshot related files
	SNAPDIR=$MNT/@
	# directory prefix for snapshot mount points
	# snaphot mount points will be created as $SNAPROOT/<snapshot-name>/_
	SNAPROOT=$MNT/@
	SNAPMNT=$SNAPROOT/_
	# file to store snapshots stack
	SNAPSHOTS="$SNAPDIR/.snapshots"

	# list|status and mount|umount commands can take -a instead of <path> argument
	if [ "$CMD" = list -o "$CMD" = status -o "$CMD" = mount -o "$CMD" = umount ] && \
		[ "$MNT" = "-a" ]; then
		return
	fi
	[ -n "$MNT" ] || usage
	[ -d "$MNT" ] || error "'$MNT' is not a directory!"
	export MNT
	S=$MNT@$snap
	SNAPTEST="ovlsnaptest"
	TESTDIR="$SNAPMNT/$SNAPTEST"
}

current_snapshot()
{
	[ -s $SNAPSHOTS ] || return
	tail -n 1 $SNAPSHOTS
}

oldest_snapshot()
{
	[ -s $SNAPSHOTS ] || return
	head -n 1 $SNAPSHOTS
}

snapshot_is_current()
{
	[ -n "$1" ] && [ "$1" = $(current_snapshot) ]
}

snapshot_is_oldest()
{
	[ -n "$1" ] && [ "$1" = $(oldest_snapshot) ]
}

snapshot_in_stack()
{
	[ -s $SNAPSHOTS ] && grep -q "^$1$" $SNAPSHOTS
}

snapshot_is_deleted()
{
	[ ! -d $SNAPDIR/$1/_ ]
}

snapshot_exists()
{
	local s=$1

	if [ -z "$s" ]; then
		# Does any snapshot exist?
		[ -s $SNAPSHOTS ]
	else
		# Does snapshot $s exist?
		[ -d $SNAPDIR/$s ] || snapshot_in_stack $s
	fi
}

create_snapshot()
{
	local s=$1

	mkdir -p $SNAPDIR/$s/u || exit 1
	mkdir -p $SNAPDIR/$s/w || exit 1
	mkdir -p $SNAPDIR/$s/_ || exit 1
	mknod $SNAPDIR/$s/u/@ c 0 0 || exit 1
	echo $s >> $SNAPSHOTS || exit 1
	sync
}

delete_snapshot()
{
	local s=$1

	umount -i $SNAPDIR/$s/_ 2>/dev/null
	rm -rf $SNAPDIR/$s/w || exit 1
	rm -rf $SNAPDIR/$s/_ || exit 1
	sync
}

remove_snapshot()
{
	local s=$1

	umount -i $SNAPDIR/$s/_ 2>/dev/null
	rm -rf $SNAPDIR/$s || exit 1
	grep -v "^$1$" $SNAPSHOTS > $SNAPSHOTS.tmp
	sync
	mv $SNAPSHOTS.tmp $SNAPSHOTS
	sync
}

remove_all_snapshots()
{
	umount -i $SNAPDIR/*/_ 2>/dev/null
	for s in `cat $SNAPSHOTS`; do
		rm -rf $SNAPDIR/$s || exit 1
		echo "snapshot $MNT@$s was removed"
	done
	rm $SNAPSHOTS
	sync
}

snapshot_is_mounted()
{
	local s=$1

	if [ -z "$s" ]; then
		grep -q "^\S\+ $SNAPMNT snapshot" /proc/mounts
	else
		grep -q "^\S\+ $SNAPROOT/$s/_ overlay" /proc/mounts
	fi
}

mount_snapshot()
{
	! snapshot_is_mounted || return
	mount -t snapshot $MNT $MNT || exit 1
}

umount_snapshot()
{
	snapshot_is_mounted || return
	umount $SNAPMNT || exit 1
}

remount_snapshot()
{
	snapshot_is_mounted || return
	# remount with -osnapshot=$(current_snapshot)
	mount $SNAPMNT -o remount || exit 1
}

umount_all_mounted_snapshots()
{
	mount -t snapshot | ( while read dev on path opt; do
		$0 umount "$path"
	done )
}

snapshot_du()
{
	du -hs "$SNAPDIR/$1/u" 2>/dev/null | \
		( read a b &&  echo $a )
}

list_snapshots()
{
	echo "Snapshots list at '$MNT':"
	echo "-------------------------"
	echo "* = current, M = mounted, D = deleted"
	echo
	echo "Status Name\tDisk-usage"
	echo "--------------------------"
	for s in $( tac $SNAPSHOTS ) ; do
		current=" "
		status=" "
		if snapshot_is_deleted $s ; then
			status="D"
		fi
		if snapshot_is_mounted $s ; then
			status="M"
		fi
		if snapshot_is_current $s ; then
			current="*"
		fi
		echo "$current$status     $s\t$(snapshot_du $s)"
	done
}

list_snapshot_mounts()
{
	local s=$1

	mount -t snapshot | ( while read dev on path opt; do
		[ -z "$s" ] || [ "$s" = "$path" ] || continue
		echo "$dev on $path"
	done )
}

list_all_mounted_snapshots()
{
	mount -t snapshot | ( while read dev on path opt; do
		$0 list "$path"
	done )
}

show_all_mounted_snapshots()
{
	mount -t snapshot | ( while read dev on path opt; do
		echo "$dev on $path $opt"
		echo "\\"
		path="${path%_}"
		mount | grep " on $path.*/_ type"
		echo .
	done )
}

snapshot_status()
{
	if ! snapshot_exists ; then
		echo "No $FSTYPE snapshots at '$MNT'."
		return 1
	fi

	S=$MNT@$(current_snapshot)
	if snapshot_is_mounted ; then
		echo "$FSTYPE snapshot $S is mounted."
	else
		echo "$FSTYPE snapshot $S is not mounted."
	fi

	echo
	echo -n "$MNT filesystem disk usage: "
	df -h $MNT | tail -n 1 | \
		( read d t u f p m && echo "$u $f $p" )
	echo -n "$MNT directory  disk usage: "
	du -hs -x --exclude=@ "$MNT" | \
		( read u m && echo "$u" )
	echo -n "$MNT snapshots  disk usage: "
	du -hs -x "$SNAPDIR" | \
		( read u m && echo "$u" )
}

# Global commands that take no <path>[@<snapshot>] argument
[ -n "$CMD" ] || usage
case "$CMD" in
  help)
	[ -n "$2" ] || usage
	# help <cmd> => <cmd> help
	exec "$0" "$2" help
	;;
  version)
	if [ "$2" = help ]; then
		echo "version: display $SCRIPT_NAME version."
		exit 0
	fi
	version
	;;
esac

# Snapshot commands that take <path>[@<snapshot>] argument
[ "$2" = help ] || parse_path_snapshot_arg "$2"
case "$CMD" in
  status|list)
	if [ "$2" = help ]; then
		echo "list: display list and status of $FSTYPE snapshots."
		echo "usage: $SCRIPT_NAME {status|list} [<path>|-a]"
		echo
		echo "run '$SCRIPT_NAME list <path>' to list $FSTYPE snapshots at <path>"
		echo "run '$SCRIPT_NAME list -a' to list all mounted $FSTYPE snapshots"
		exit 0
	fi
	if [ "$MNT" = "-a" ]; then
		# List all snapshot mounts
		echo "$FSTYPE snapshot mounts:"
		echo "------------------------"
		list_snapshot_mounts
		echo .
		# List all snapshots overlays of all snapshot mounts
		list_all_mounted_snapshots
		exit 0
	elif snapshot_status ; then
		echo .
		list_snapshots
	fi
	echo .
	;;

  create|take)
	if [ "$2" = help ]; then
		echo "$CMD: create a new snapshot."
		echo "usage: $SCRIPT_NAME {create|take} <path>[[/]@[/]<snapshot-name>] (default-name=<date.time>)"
		exit 0
	fi
	if [ -z "$snap" ] ; then
		# default snapshot-name is <date.time>
		snap=$( date -u +%y%m%d.%H%M%S )
		S=$MNT@$snap
	fi
	if snapshot_exists $snap ; then
		error "snapshot $S already exists!"
	fi

	# For now new snapshot requires umount/mount of all snapshots
	create_snapshot $snap
	remount_snapshot
	echo "snapshot $S was created"
	echo .
	;;
  delete)
	if [ "$2" = help ]; then
		echo "delete: umount a snapshot and mark it for deletion."
		echo "any non-mounted snapshot can be marked for deletion"
		echo "but some snapshot deletion is deferred to later time."
		echo "usage: $SCRIPT_NAME delete <path>[/]@[/]<snapshot-name>"
		exit 0
	fi
	[ -n "$snap" ] || usage
	if snapshot_is_deleted $snap ; then
		error "snapshot $S already deleted!"
	fi
	if ! snapshot_exists $snap ; then
		error "snapshot $S doesn't exist!"
	fi
	if snapshot_is_current $snap ; then
		error "current snapshot $S cannot be deleted!"
	fi

	delete_snapshot $snap
	echo "snapshot $S was deleted"
	echo .
	;;
  remove)
	if [ "$2" = help ]; then
		echo "remove: delete a snapshot permanently."
		echo "this command will fail for active snapshot and snapshots"
		echo "in use by older snapshots. try using the delete command."
		echo "usage: $SCRIPT_NAME remove <path>[/]@[/]<snapshot-name>"
		exit 0
	fi
	[ -n "$snap" ] || usage
	if ! snapshot_exists $snap ; then
		error "snapshot $S doesn't exist!"
	fi
	if ! snapshot_is_oldest $snap ; then
		error "non-oldest snapshot $S cannot be removed!"
	fi

	remove_snapshot $snap
	remount_snapshot
	echo "snapshot $S was removed"
	echo .
	;;
  clean)
	if [ "$2" = help ]; then
		echo "clean: remove all snapshots."
		echo "usage: $SCRIPT_NAME clean <path>"
		exit 0
	fi
	[ -z "$snap" ] || usage
	if ! snapshot_exists ; then
		echo "No $FSTYPE snapshots at '$MNT'."
		exit 0
	fi

	remove_all_snapshots
	remount_snapshot
	echo "all snapshots at '$MNT' removed"
	echo .
	;;

  mount)
	if [ "$2" = help ]; then
		echo "mount: mount all $FSTYPE snapshots at <path>."
		echo "usage: $SCRIPT_NAME mount [<path>|-a]"
		echo
		echo "run '$SCRIPT_NAME mount -a' to show all mounted $FSTYPE snapshots"
		exit 0
	fi
	if [ "$MNT" = "-a" ]; then
		# show all snapshot mounts and overlays
		show_all_mounted_snapshots
		exit 0
	fi
	S=$MNT@$(current_snapshot)
	if snapshot_is_mounted; then
		error "snapshot $S is already mounted!"
	fi
	mount_snapshot
	echo "snapshot $S was mounted"
	echo .
	;;
  umount)
	if [ "$2" = help ]; then
		echo "umount: unmount all $FSTYPE snapshots at <path>."
		echo "usage: $SCRIPT_NAME umount [<path>|-a]"
		echo
		echo "run '$SCRIPT_NAME umount -a' to unmount all mounted $FSTYPE snapshots"
		exit 0
	fi
	if [ "$MNT" = "-a" ]; then
		# Unmount all snapshot mounts
		umount_all_mounted_snapshots
		exit 0
	fi
	S=$MNT@$(current_snapshot)
	if ! snapshot_is_mounted; then
		error "snapshot $S is not mounted!"
	fi
	umount_snapshot
	echo "snapshot $S was unmounted"
	echo .
	;;

# Snapshot sanity tests
  mktest)
	if [ -d $TESTDIR/A ] ; then
		exit 0
	fi
	mkdir -p $TESTDIR
	mkdir $TESTDIR/A
	mkdir $TESTDIR/B
	mkdir $TESTDIR/C
	mkdir $TESTDIR/D
	mkdir $TESTDIR/E
	echo aligator > $TESTDIR/A/a.txt
	echo bizon > $TESTDIR/B/b.txt
	echo camel > $TESTDIR/C/c.txt
	;;
  rmtest)
	rm -rf $TESTDIR 2> /dev/null
	;;
  lstest)
	if [ -z "$snap" ] ; then
		echo Files in snapshot mount:
		d=$TESTDIR
	else
		echo "Files in snapshot $snap:"
		d=$SNAPROOT/$snap/_/$SNAPTEST
	fi
	if [ -d $d ] ; then
		cd $d > /dev/null
		grep -v xxx ?/* 2>/dev/null
		echo .
		if [ -s md5list ]; then
			md5sum -c md5list || exit 1
		fi
		cd - > /dev/null
		echo .
	fi
	;;
  tests)
	if [ "$2" = help ]; then
		echo "tests: run snapshot sanity tests 1..N."
		echo "usage: $SCRIPT_NAME tests <path> [test-number] [file-size-mb]"
		echo "file-size-mb: test file size in mega bytes (default = 1)"
		exit 0
	fi
	N=4
	[ -z "$3" ] || N=$3
	$0 umount $MNT
	for s in $( cat $SNAPSHOTS 2> /dev/null ) ; do
		$0 remove $SNAPDIR/$s 2> /dev/null
	done
	$0 mount $MNT
	for n in $( seq 0 $N ) ; do
		$0 test $MNT $n $4 || exit 1
	done
	$0 lstest $MNT
	for n in $( seq 1 $N ) ; do
		$0 lstest $SNAPDIR/$n
	done
	;;
  test)
	if [ "$2" = help ]; then
		echo "test: run snapshot sanity test N."
		echo "usage: $SCRIPT_NAME test <path> [test-number] [file-size-mb]"
		echo "file-size-mb: test file size in mega bytes (default = 1)"
		exit 0
	fi
	n=1
	[ -z "$3" ] || n=$3
	if [ "$n" = 0 ] ; then
		$0 rmtest $MNT
		exit 0
	fi
	$0 mktest $MNT
	echo
	echo Running snapshot test $n:
	echo ------------------------
	M=1
	[ -z "$4" ] || M=$4
	F=${M}M
	cd $TESTDIR > /dev/null
	NOTRUNC="conv=notrunc"
	# uncomment the following line to run in-place write tests
	INPLACE=$NOTRUNC
	# uncomment the following line to run direct I/O write tests
	DIRECT="oflag=direct"
	TRUNCSIZE=4
	echo Appending $F zeros to $F.1 $DIRECT
	# append writes to new allocated blocks
	dd if=/dev/zero bs=1M count=$M of=$F.1 $NOTRUNC oflag=append $DIRECT status=noxfer \
		2>/dev/null || exit 1
	echo Writing $F random data to $n files
	for i in $( seq 1 $n ) ; do
		# 1st rewrite splits reflink extents and allocates new blocks
		dd if=/dev/urandom bs=1M count=$M of=$F.$i $INPLACE status=noxfer \
			2>/dev/null || exit 1
		# subsequent rewrites doesn't change reflink extents
		dd if=/dev/urandom bs=1M count=$M of=$F.1 $INPLACE $DIRECT status=noxfer \
			2>/dev/null || exit 1
	done
	for i in $( seq 1 $n ) ; do
		md5sum $F.$i || exit 1
	done >> md5list
	cd - > /dev/null
	echo .
	$0 lstest $MNT || exit 1
	s=$n
	$0 take $SNAPDIR/$s || exit 1
	case "$n" in
  	  1)
		echo Create test:
		echo ------------
		echo 'Creating d.txt'
		echo dodo > $TESTDIR/D/d.txt
		echo 'Creating e.txt'
		echo emu > $TESTDIR/E/e.txt
	  ;;
	  2)
		echo Write test:
		echo -----------
		echo 'Writing b.txt (append)'
		echo 'barracuda' >> $TESTDIR/B/b.txt
		echo 'Writing c.txt (truncate)'
		echo 'crocodile' > $TESTDIR/C/c.txt
	  ;;
	  3)
		echo Remove test:
		echo ------------
		echo "Truncating c.txt (to size $TRUNCSIZE)"
		truncate -s $TRUNCSIZE $TESTDIR/C/c.txt
		echo 'Removing d.txt'
		rm $TESTDIR/D/d.txt
	  ;;
	  4)
		echo Restore test:
		echo -------------
		f=1
		echo 'Restoring from snapshot' $f
		rm -rf $TESTDIR/?
		cp -R $SNAPROOT/$f/_/$SNAPTEST/? $TESTDIR/
	  ;;
	esac || exit 1
	cd $TESTDIR > /dev/null
	md5sum ?/* > md5list || exit 1
	cd - > /dev/null
	echo .
	$0 lstest $MNT || exit 1
	$0 lstest $SNAPDIR/$s || exit 1
	$0 list $MNT
	;;

  *)
	usage
esac

exit 0
