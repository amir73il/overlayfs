#!/bin/sh
#
# Overlayfs snapshot management script
#
#-----------------------------------------------------------------------
#
# Copyright (C) 2016 CTERA Networks. All Rights Reserved.
# Author: Amir Goldstein <amir73il@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it would be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write the Free Software Foundation,
# Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#-----------------------------------------------------------------------
#

SCRIPT_NAME=$(basename $0)
SCRIPT_VER=0.1
FSTYPE=overlay
SCRIPT_DESC="$FSTYPE snapshot management script"
CMD="$1"

version()
{
	echo "$SCRIPT_NAME v$SCRIPT_VER ($SCRIPT_DESC)"
}

usage()
{
	version
	echo "usage: $SCRIPT_NAME help [cmd]"
	echo "usage: $SCRIPT_NAME version"
	echo
	echo "$FSTYPE snapshot commands:"
	echo "usage: $SCRIPT_NAME {mount|status} <path>"
	echo "usage: $SCRIPT_NAME {umount|list} [<path>|-a]"
	echo "usage: $SCRIPT_NAME {create|take}  <path>[[/]@[/]<snapshot-name>] (default-name=<date.time>)"
	echo "usage: $SCRIPT_NAME {delete|remove} <path>[/]@[/]<snapshot-name>"
	echo
	echo "snapshot command parameter may be given in ZFS style <path>@<snapshot-name>"
        echo "and it may be given as the snapshot directory path <path>/@/<snapshot-name>."
	echo "If <snapshot-name> part is omitted, command may apply to all snapshots (e.g. umount)."
	echo
	echo "$FSTYPE snapshot test commands:"
	echo "usage: $SCRIPT_NAME {test|tests} <path> [test-number] [file-size-mb]"
	echo
	exit 1
}

error()
{
	echo "$SCRIPT_NAME: $CMD: $1" >&2
	exit 1
}

# parse <path>[[/]@[/]<snapshot-name>] argument
parse_path_snapshot_arg()
{
	MNT=$( echo $1 | ( IFS=$IFS@ ; read a b ; echo $a ) )
	snap=$( echo $1 | ( IFS=$IFS@ ; read a b ; echo $b ) )
	# strip / from <path>/ and /<snapshot-name>
	MNT=${MNT%/}
	snap=${snap#/}
	# directory inside <path> to store snapshot related files
	SNAPDIR=$MNT/@
	# directory prefix for snapshot mount points
	# snaphot mount points will be created as $SNAPMNT<snapshot-name>
	SNAPMNT=$MNT/@/
	# file to store snapshots stack
	SNAPSHOTS="$SNAPDIR/.snapshots"

	# list and umount commands can take -a instead of <path> argument
	if [ "$CMD" = list -o "$CMD" = umount ] && [ "$MNT" = "-a" ]; then
		return
	fi
	[ -n "$MNT" ] || usage
	[ -d "$MNT" ] || error "'$MNT' is not a directory!"
	export MNT
	S=$MNT@$snap
	SNAPTEST="ovlsnaptest"
	TESTDIR="$MNT/$SNAPTEST"
}

current_snapshot()
{
	[ -s $SNAPSHOTS ] || return
	tail -n 1 $SNAPSHOTS
}

oldest_snapshot()
{
	[ -s $SNAPSHOTS ] || return
	head -n 1 $SNAPSHOTS
}

snapshot_is_current()
{
	[ -n "$1" ] && [ "$1" = $(current_snapshot) ]
}

snapshot_is_oldest()
{
	[ -n "$1" ] && [ "$1" = $(oldest_snapshot) ]
}

snapshot_in_stack()
{
	[ -s $SNAPSHOTS ] && grep -q "^$1$" $SNAPSHOTS
}

snapshot_is_deleted()
{
	[ ! -d $SNAPDIR/$1 ]
}

snapshot_exists()
{
	local s=$1

	if [ -z "$s" ]; then
		# Does any snapshot exist?
		[ -s $SNAPSHOTS ]
	else
		# Does snapshot $s exist?
		[ -d $SNAPDIR/$s ] || [ -d $SNAPDIR/.$s ] || snapshot_in_stack $s
	fi
}

create_snapshot()
{
	local s=$1

	mkdir -p $SNAPDIR/$s/u || exit 1
	mkdir -p $SNAPDIR/$s/w || exit 1
	mknod $SNAPDIR/$s/u/@ c 0 0 || exit 1
	echo $s >> $SNAPSHOTS || exit 1
	sync
}

delete_snapshot()
{
	local s=$1

	umount -i $SNAPDIR/$s 2>/dev/null
	rm -rf $SNAPDIR/$s/w || exit 1
	mv $SNAPDIR/$s $SNAPDIR/.$s|| exit 1
	sync
}

remove_snapshot()
{
	local s=$1

	snapshot_is_deleted $s || delete_snapshot $s
	rm -rf $SNAPDIR/.$s || exit 1
	grep -v "^$1$" $SNAPSHOTS > $SNAPSHOTS.tmp
	sync
	mv $SNAPSHOTS.tmp $SNAPSHOTS
	sync
}

snapshot_is_mounted()
{
	local s=$1

	if [ -z "$s" ]; then
		grep -q "^\S\+ $MNT snapshot" /proc/mounts
	else
		grep -q "^\S\+ $SNAPMNT$s overlay" /proc/mounts
	fi
}

mount_snapshot()
{
	! snapshot_is_mounted || return
	mount -t snapshot snapshot $MNT || exit 1
}

umount_snapshot()
{
	snapshot_is_mounted || return
	umount $MNT || exit 1
}

umount_all_mounted_snapshots()
{
	mount -t snapshot | ( while read dev on path opt; do
		$0 umount "$path"
	done )
}

list_snapshots()
{
	echo "Snapshots list at '$MNT':"
	echo "-------------------------"
	echo "* = current, M = mounted, D = deleted"
	echo
	echo "Status Name"
	echo "-------------------------"
	for s in $( tac $SNAPSHOTS ) ; do
		current=" "
		status=" "
		if snapshot_is_deleted $s ; then
			status="D"
		fi
		if snapshot_is_mounted $s ; then
			status="M"
		fi
		if snapshot_is_current $s ; then
			current="*"
		fi
		echo "$current$status     $s"
	done
}

list_snapshot_mounts()
{
	local s=$1

	mount -t snapshot | ( while read dev on path opt; do
		[ -z "$s" ] || [ "$s" = "$path" ] || continue
		echo "$dev on $path"
	done )
}

list_all_mounted_snapshots()
{
	mount -t snapshot | ( while read dev on path opt; do
		$0 list "$path"
	done )
}

snapshot_status()
{
	if ! snapshot_exists ; then
		echo "No $FSTYPE snapshots at '$MNT'."
		return 1
	fi

	S=$MNT@$(current_snapshot)
	if snapshot_is_mounted ; then
		echo "$FSTYPE snapshot $S is mounted."
	else
		echo "$FSTYPE snapshot $S is not mounted."
	fi
}

# Global commands that take no <path>[@<snapshot>] argument
[ -n "$CMD" ] || usage
case "$CMD" in
  help)
	[ -n "$2" ] || usage
	# help <cmd> => <cmd> help
	exec "$0" "$2" help
	;;
  version)
	if [ "$2" = help ]; then
		echo "version: display $SCRIPT_NAME version."
		exit 0
	fi
	version
	;;
esac

# Snapshot commands that take <path>[@<snapshot>] argument
[ "$2" = help ] || parse_path_snapshot_arg "$2"
case "$CMD" in
  status)
	if [ "$2" = help ]; then
		echo "status: display status of $FSTYPE snapshot mount at <path>."
		echo "usage: $SCRIPT_NAME status <path>"
		exit 0
	fi
	snapshot_status
	echo .
	;;
  list)
	if [ "$2" = help ]; then
		echo "list: display list and status of $FSTYPE snapshots."
		echo "usage: $SCRIPT_NAME list [<path>|-a]"
		echo
		echo "run '$SCRIPT_NAME list <path>' to list $FSTYPE snapshots at <path>"
		echo "run '$SCRIPT_NAME list -a' to list all mounted $FSTYPE snapshots"
		exit 0
	fi
	if [ "$MNT" = "-a" ]; then
		# List all snapshot mounts
		echo "$FSTYPE snapshot mounts:"
		echo "------------------------"
		list_snapshot_mounts
		echo .
		# List all snapshots overlays of all snapshot mounts
		list_all_mounted_snapshots
		exit 0
	elif snapshot_status ; then
		echo .
		list_snapshots
	fi
	echo .
	;;

  create|take)
	if [ "$2" = help ]; then
		echo "$CMD: create a new snapshot."
		echo "usage: $SCRIPT_NAME {create|take} <path>[[/]@[/]<snapshot-name>] (default-name=<date.time>)"
		exit 0
	fi
	if [ -z "$snap" ] ; then
		# default snapshot-name is <date.time>
		snap=$( date -u +%y%m%d.%H%M%S )
		S=$MNT@$snap
	fi
	if snapshot_exists $snap ; then
		error "snapshot $S already exists!"
	fi

	# For now new snapshot requires umount/mount of all snapshots
	umount_snapshot
	create_snapshot $snap
	mount_snapshot
	echo "snapshot $S was created"
	echo .
	;;
  delete)
	if [ "$2" = help ]; then
		echo "delete: umount a snapshot and mark it for deletion."
		echo "any non-mounted snapshot can be marked for deletion"
		echo "but some snapshot deletion is deferred to later time."
		echo "usage: $SCRIPT_NAME delete <path>[/]@[/]<snapshot-name>"
		exit 0
	fi
	[ -n "$snap" ] || usage
	if snapshot_is_deleted $snap ; then
		error "snapshot $S already deleted!"
	fi
	if ! snapshot_exists $snap ; then
		error "snapshot $S doesn't exist!"
	fi
	if snapshot_is_current $snap ; then
		error "current snapshot $S cannot be deleted!"
	fi

	delete_snapshot $snap
	echo "snapshot $S was deleted"
	echo .
	;;
  remove)
	if [ "$2" = help ]; then
		echo "remove: delete a snapshot permanently."
		echo "this command will fail for active snapshot and snapshots"
		echo "in use by older snapshots. try using the delete command."
		echo "usage: $SCRIPT_NAME remove <path>[/]@[/]<snapshot-name>"
		exit 0
	fi
	[ -n "$snap" ] || usage
	if snapshot_is_mounted; then
		error "cannot remove snapshot while snapshots are mounted!"
	fi
	if ! snapshot_exists $snap ; then
		error "snapshot $S doesn't exist!"
	fi
	if ! snapshot_is_oldest $snap ; then
		error "non-oldest snapshot $S cannot be removed!"
	fi

	remove_snapshot $snap
	echo "snapshot $S was removed"
	echo .
	;;

  mount)
	if [ "$2" = help ]; then
		echo "mount: mount all $FSTYPE snapshots at <path>."
		echo "usage: $SCRIPT_NAME mount <path>"
		exit 0
	fi
	S=$MNT@$(current_snapshot)
	if snapshot_is_mounted; then
		error "snapshot $S is already mounted!"
	fi
	mount_snapshot
	echo "snapshot $S was mounted"
	echo .
	;;
  umount)
	if [ "$2" = help ]; then
		echo "umount: unmount all $FSTYPE snapshots at <path>."
		echo "usage: $SCRIPT_NAME umount <path>"
		exit 0
	fi
	if [ "$MNT" = "-a" ]; then
		# Unmount all snapshot mounts
		umount_all_mounted_snapshots
		exit 0
	fi
	S=$MNT@$(current_snapshot)
	if ! snapshot_is_mounted; then
		error "snapshot $S is not mounted!"
	fi
	umount_snapshot
	echo "snapshot $S was unmounted"
	echo .
	;;

# Snapshot sanity tests
  mktest)
	if [ -d $TESTDIR/A ] ; then
		exit 0
	fi
	mkdir -p $TESTDIR
	mkdir $TESTDIR/A
	mkdir $TESTDIR/B
	mkdir $TESTDIR/C
	mkdir $TESTDIR/D
	mkdir $TESTDIR/E
	echo aligator > $TESTDIR/A/a.txt
	echo bizon > $TESTDIR/B/b.txt
	echo camel > $TESTDIR/C/c.txt
	;;
  rmtest)
	rm -rf $TESTDIR 2> /dev/null
	;;
  lstest)
	if [ -z "$snap" ] ; then
		echo Files in snapshot mount:
		d=$TESTDIR
	else
		echo "Files in snapshot $snap:"
		d=$SNAPMNT$snap/$SNAPTEST
	fi
	if [ -d $d ] ; then
		cd $d > /dev/null
		grep -v xxx ?/* 2>/dev/null
		[ -s md5list ] && (md5sum -c md5list || exit 1)
		cd - > /dev/null
		echo .
	fi
	;;
  tests)
	if [ "$2" = help ]; then
		echo "tests: run snapshot sanity tests 1..N."
		echo "usage: $SCRIPT_NAME tests <path> [test-number] [file-size-mb]"
		echo "file-size-mb: test file size in mega bytes (default = 1)"
		exit 0
	fi
	N=4
	[ -z "$3" ] || N=$3
	$0 umount $MNT
	for s in $( cat $SNAPSHOTS 2> /dev/null ) ; do
		$0 remove $SNAPMNT$s 2> /dev/null
	done
	$0 mount $MNT
	for n in $( seq 0 $N ) ; do
		$0 test $MNT $n $4 || exit 1
	done
	$0 lstest $MNT
	for n in $( seq 1 $N ) ; do
		$0 lstest $SNAPMNT$n
	done
	;;
  test)
	if [ "$2" = help ]; then
		echo "test: run snapshot sanity test N."
		echo "usage: $SCRIPT_NAME test <path> [test-number] [file-size-mb]"
		echo "file-size-mb: test file size in mega bytes (default = 1)"
		exit 0
	fi
	n=1
	[ -z "$3" ] || n=$3
	if [ "$n" = 0 ] ; then
		$0 rmtest $MNT
		exit 0
	fi
	$0 mktest $MNT
	echo
	echo Running snapshot test $n:
	echo ------------------------
	M=1
	[ -z "$4" ] || M=$4
	F=${M}M
	cd $TESTDIR > /dev/null
	NOTRUNC="conv=notrunc"
	# uncomment the following line to run in-place write tests
	INPLACE=$NOTRUNC
	# uncomment the following line to run direct I/O write tests
	DIRECT="oflag=direct"
	TRUNCSIZE=4
	echo Appending $F zeros to $F.1 $DIRECT
	# append writes to new allocated blocks
	dd if=/dev/zero bs=1M count=$M of=$F.1 $NOTRUNC oflag=append $DIRECT status=noxfer || exit 1
	echo Writing $F random data to $n files
	for i in $( seq 1 $n ) ; do
		# 1st rewrite moves existing blocks to snapshot and allocates new blocks
		dd if=/dev/urandom bs=1M count=$M of=$F.$i $INPLACE status=noxfer || exit 1
		# subsequent rewrites doesn't move blocks to snapshot
		dd if=/dev/urandom bs=1M count=$M of=$F.1 $INPLACE $DIRECT status=noxfer || exit 1
	done
	for i in $( seq 1 $n ) ; do
		md5sum $F.$i || exit 1
	done > md5list
	cd - > /dev/null
	$0 lstest $MNT || exit 1
	s=$n
	$0 take $SNAPMNT$s || exit 1
	case "$n" in
  	  1)
		echo Create test:
		echo ------------
		echo 'Creating d.txt'
		echo dodo > $TESTDIR/D/d.txt
		echo 'Creating e.txt'
		echo emu > $TESTDIR/E/e.txt
	  ;;
	  2)
		echo Write test:
		echo -----------
		echo 'Writing b.txt (append)'
		echo 'barracuda' >> $TESTDIR/B/b.txt
		echo 'Writing c.txt (truncate)'
		echo 'crocodile' > $TESTDIR/C/c.txt
	  ;;
	  3)
		echo Remove test:
		echo ------------
		echo "Truncating c.txt (to size $TRUNCSIZE)"
		truncate -s $TRUNCSIZE $TESTDIR/C/c.txt
		echo 'Removing d.txt'
		rm $TESTDIR/D/d.txt
	  ;;
	  4)
		echo Restore test:
		echo -------------
		f=1
		echo 'Restoring from snapshot' $f
		rm -rf $TESTDIR/?
		cp -R $SNAPMNT$f/$SNAPTEST/? $TESTDIR/
	  ;;
	esac || exit 1
	echo .
	$0 lstest $MNT || exit 1
	$0 lstest $SNAPMNT$s || exit 1
	$0 list $MNT
	;;

  *)
	usage
esac

exit 0
